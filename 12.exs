# The sequence of triangle numbers is generated by adding the natural numbers.
# So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first
# ten terms would be:
#
# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
#
# Let us list the factors of the first seven triangle numbers:
#
#      1: 1
#      3: 1,3
#      6: 1,2,3,6
#     10: 1,2,5,10
#     15: 1,3,5,15
#     21: 1,3,7,21
#     28: 1,2,4,7,14,28
#
# We can see that 28 is the first triangle number to have over five divisors.
#
# What is the value of the first triangle number to have over five hundred
# divisors?
defmodule Prime do
  def prime?(n) do
    cond do
      n == 2 -> true
      n == 3 -> true
      rem(n, 2) == 0 -> false
      rem(n, 3) == 0 -> false
      true -> prime_helper(n, 5, 2)
    end
  end

  def prime_factors(number) do
    Stream.unfold(number, fn n ->
      cond do
        n == 0 -> nil
        prime?(n) -> {n, 0}
        true ->
          d = Stream.unfold(2, &({&1, &1 + 1}))
            |> Stream.filter(&prime?(&1))
            |> Stream.filter(&(rem(n, &1) == 0))
            |> Enum.at(0)
          {d, div(n, d)}
      end
    end)
      |> Enum.to_list
  end

  defp prime_helper(n, i, w) do
    cond do
      i * i <= n ->
        if rem(n, i) == 0 do
          false
        else
          prime_helper(n, i + w, 6 - w)
        end
      true -> true
    end
  end
end

divisor_count = fn number ->
  if number == 1 do
    1
  else
    # http://mathforum.org/library/drmath/view/55843.html
    Prime.prime_factors(number)
      |> Enum.reduce(%{}, fn x, acc ->
        Map.update(acc, x, 1, &(&1 + 1))
      end)
      |> Map.values
      |> Enum.reduce(1, &((&1 + 1) * &2))
  end
end

Stream.unfold(1, &({&1, &1 + 1}))
  |> Stream.scan(&(&1 + &2))
  |> Stream.filter(&(divisor_count.(&1) > 500))
  |> Enum.at(0)
  |> IO.inspect
